---
layout: page
title: ASP.NET Core å®ç°æ ‡ç­¾å›¾ç‰‡æ‰¹é‡æ‰“åŒ…ä¸‹è½½åŠŸèƒ½
category: æŠ€æœ¯
tags: net
---

## ä¸šåŠ¡åœºæ™¯

åœ¨ç‰©æµæ ‡ç­¾ç®¡ç†ç³»ç»Ÿä¸­ï¼Œæˆ‘ä»¬éœ€è¦å®ç°ä¸€ä¸ªåŠŸèƒ½ï¼šæ ¹æ®è®¡åˆ’ç¼–å·æ‰¹é‡ä¸‹è½½æ ‡ç­¾å›¾ç‰‡ã€‚å…·ä½“éœ€æ±‚å¦‚ä¸‹ï¼š

- æ¯ä¸ªè®¡åˆ’åŒ…å«å¤šä¸ªç®±å­
- æ¯ä¸ªç®±å­éœ€è¦è´´å¤šå¼ æ ‡ç­¾
- æ ‡ç­¾å›¾ç‰‡å­˜å‚¨åœ¨è¿œç¨‹æœåŠ¡å™¨ï¼Œæä¾›URLåœ°å€
- éœ€è¦å°†å›¾ç‰‡æŒ‰ `è®¡åˆ’ç¼–å·/ç®±å·/æ ‡ç­¾å›¾ç‰‡` çš„ç›®å½•ç»“æ„æ‰“åŒ…æˆZIPæ–‡ä»¶
- ç›´æ¥è¿”å›æ–‡ä»¶æµç»™å‰ç«¯ä¸‹è½½

## æŠ€æœ¯éš¾ç‚¹

### 1. å†…å­˜å ç”¨é—®é¢˜

å¦‚æœç®€å•åœ°å°†æ‰€æœ‰å›¾ç‰‡ä¸‹è½½åˆ°å†…å­˜ï¼Œå†æ‰“åŒ…æˆZIPï¼Œå½“å›¾ç‰‡æ•°é‡è¾ƒå¤šæ—¶ä¼šå¯¼è‡´ï¼š
- å†…å­˜å ç”¨è¿‡é«˜ï¼ˆ100å¼ 5MBå›¾ç‰‡ â‰ˆ 1GBå†…å­˜ï¼‰
- æœåŠ¡å™¨å‹åŠ›å¤§
- å¯èƒ½å¯¼è‡´OOMï¼ˆå†…å­˜æº¢å‡ºï¼‰

### 2. ASP.NET Core é™åˆ¶

- é»˜è®¤ç¦ç”¨åŒæ­¥I/Oæ“ä½œ
- ABP Frameworkçš„è‡ªåŠ¨éªŒè¯æœºåˆ¶
- å“åº”å‹ç¼©ä¸­é—´ä»¶å†²çª

## è§£å†³æ–¹æ¡ˆ

### æ ¸å¿ƒæ€è·¯ï¼šæµå¼å¤„ç†

é‡‡ç”¨**è¾¹ä¸‹è½½è¾¹å‹ç¼©è¾¹ä¼ è¾“**çš„ç­–ç•¥ï¼Œé¿å…å¤§é‡æ•°æ®åœ¨å†…å­˜ä¸­å †ç§¯ï¼š

1. ä½¿ç”¨ `HttpCompletionOption.ResponseHeadersRead` æµå¼ä¸‹è½½å›¾ç‰‡
2. ç›´æ¥å°†ä¸‹è½½æµå¤åˆ¶åˆ°ZIP Entryæµä¸­
3. ZIPæ–‡ä»¶ç›´æ¥å†™å…¥HTTPå“åº”æµ
4. å†…å­˜å ç”¨æ§åˆ¶åœ¨80KBç¼“å†²åŒºçº§åˆ«

## å®Œæ•´å®ç°

### 1. æ•°æ®æ¨¡å‹

```csharp
// è®¡åˆ’ä»»åŠ¡æ¨¡å‹
public class PlanLabelTask
{
    public string PlanNo { get; set; }  // è®¡åˆ’ç¼–å·
    public List<BoxLabelTask> Boxes { get; set; }  // ç®±å­åˆ—è¡¨
}

// ç®±å­æ ‡ç­¾æ¨¡å‹
public class BoxLabelTask
{
    public string BoxNo { get; set; }  // ç®±å·
    public List<string> LabelUrls { get; set; }  // æ ‡ç­¾URLåˆ—è¡¨
}
```

### 2. æœåŠ¡å±‚å®ç°

```csharp
public interface ILabelPackService
{
    Task StreamLabelsToZipAsync(
        List<PlanLabelTask> plans,
        Stream outputStream,
        CancellationToken cancellationToken = default);
}

public class LabelPackService : ILabelPackService
{
    private readonly IHttpClientFactory _httpClientFactory;
    private readonly ILogger<LabelPackService> _logger;
    private const int BufferSize = 81920; // 80KBç¼“å†²åŒº

    public LabelPackService(
        IHttpClientFactory httpClientFactory,
        ILogger<LabelPackService> logger)
    {
        _httpClientFactory = httpClientFactory;
        _logger = logger;
    }

    public async Task StreamLabelsToZipAsync(
        List<PlanLabelTask> plans,
        Stream outputStream,
        CancellationToken cancellationToken = default)
    {
        using var archive = new ZipArchive(outputStream, ZipArchiveMode.Create, leaveOpen: true);
        var httpClient = _httpClientFactory.CreateClient();
        httpClient.Timeout = TimeSpan.FromMinutes(10);

        foreach (var plan in plans)
        {
            var sanitizedPlanNo = SanitizeFolderName(plan.PlanNo);

            if (plan.Boxes == null || !plan.Boxes.Any())
                continue;

            foreach (var box in plan.Boxes)
            {
                var sanitizedBoxNo = SanitizeFolderName(box.BoxNo);

                if (box.LabelUrls == null || !box.LabelUrls.Any())
                    continue;

                for (int i = 0; i < box.LabelUrls.Count; i++)
                {
                    try
                    {
                        var labelUrl = box.LabelUrls[i];

                        // ğŸ”‘ å…³é”®ï¼šæµå¼ä¸‹è½½ï¼Œä¸ä¸€æ¬¡æ€§åŠ è½½åˆ°å†…å­˜
                        using var response = await httpClient.GetAsync(
                            labelUrl,
                            HttpCompletionOption.ResponseHeadersRead,
                            cancellationToken);
                        response.EnsureSuccessStatusCode();

                        var extension = GetFileExtension(labelUrl, response);
                        var entryName = $"{sanitizedPlanNo}/{sanitizedBoxNo}/æ ‡ç­¾_{i + 1}{extension}";

                        var entry = archive.CreateEntry(entryName, CompressionLevel.Optimal);

                        // ğŸ”‘ å…³é”®ï¼šæµå¼å¤åˆ¶ï¼Œä¸å ç”¨å¤§é‡å†…å­˜
                        using var entryStream = entry.Open();
                        using var imageStream = await response.Content.ReadAsStreamAsync(cancellationToken);

                        await imageStream.CopyToAsync(entryStream, BufferSize, cancellationToken);

                        _logger.LogInformation($"å·²æ·»åŠ : {entryName}");
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError(ex, $"å¤„ç†æ ‡ç­¾å¤±è´¥: è®¡åˆ’={plan.PlanNo}, ç®±å·={box.BoxNo}");
                    }
                }
            }
        }
    }

    private string SanitizeFolderName(string folderName)
    {
        var invalidChars = Path.GetInvalidFileNameChars();
        foreach (var c in invalidChars)
        {
            folderName = folderName.Replace(c, '_');
        }
        return folderName;
    }

    private string GetFileExtension(string url, HttpResponseMessage response)
    {
        try
        {
            // ä¼˜å…ˆä»Content-Typeè·å–
            if (response.Content.Headers.ContentType?.MediaType != null)
            {
                var mediaType = response.Content.Headers.ContentType.MediaType;
                return mediaType switch
                {
                    "image/jpeg" => ".jpg",
                    "image/png" => ".png",
                    "image/gif" => ".gif",
                    "image/webp" => ".webp",
                    "image/bmp" => ".bmp",
                    _ => Path.GetExtension(new Uri(url).AbsolutePath)
                };
            }

            var extension = Path.GetExtension(new Uri(url).AbsolutePath);
            return string.IsNullOrEmpty(extension) ? ".jpg" : extension;
        }
        catch
        {
            return ".jpg";
        }
    }
}
```

### 3. Controllerå®ç°

```csharp
[ApiController]
[Route("api/[controller]")]
public class LabelController : ControllerBase
{
    private readonly ILabelPackService _labelPackService;
    private readonly ILogger<LabelController> _logger;

    public LabelController(
        ILabelPackService labelPackService,
        ILogger<LabelController> logger)
    {
        _labelPackService = labelPackService;
        _logger = logger;
    }

    [HttpPost("pack")]
    [DisableValidation]  // âš ï¸ ç¦ç”¨ABPéªŒè¯
    [DisableRequestSizeLimit]  // âš ï¸ å…è®¸å¤§æ–‡ä»¶
    public async Task<IActionResult> PackLabels(
        [FromBody] List<PlanLabelTask> plans,
        CancellationToken cancellationToken)
    {
        try
        {
            if (plans == null || !plans.Any())
            {
                return BadRequest("è®¡åˆ’åˆ—è¡¨ä¸èƒ½ä¸ºç©º");
            }

            // âš ï¸ å¯ç”¨åŒæ­¥I/Oï¼ˆZipArchiveéœ€è¦ï¼‰
            var syncIOFeature = HttpContext.Features
                .Get<IHttpBodyControlFeature>();
            if (syncIOFeature != null)
            {
                syncIOFeature.AllowSynchronousIO = true;
            }

            var totalBoxes = plans.Sum(p => p.Boxes?.Count ?? 0);
            var totalLabels = plans.Sum(p => p.Boxes?.Sum(b => b.LabelUrls?.Count ?? 0) ?? 0);
            _logger.LogInformation(
                $"å¼€å§‹æ‰“åŒ…æ ‡ç­¾ï¼Œå…±{plans.Count}ä¸ªè®¡åˆ’ï¼Œ{totalBoxes}ä¸ªç®±å­ï¼Œ{totalLabels}ä¸ªæ ‡ç­¾");

            var fileName = $"Labels_{DateTime.Now:yyyyMMddHHmmss}.zip";

            // è®¾ç½®å“åº”å¤´
            Response.ContentType = "application/zip";
            Response.Headers.Append("Content-Disposition",
                $"attachment; filename=\"{fileName}\"");

            // ğŸ”‘ å…³é”®ï¼šç›´æ¥æµå¼å†™å…¥HTTPå“åº”
            await _labelPackService.StreamLabelsToZipAsync(
                plans,
                Response.Body,
                cancellationToken);

            return new EmptyResult();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "æ‰“åŒ…æ ‡ç­¾å¤±è´¥");

            if (Response.HasStarted)
            {
                _logger.LogError("å“åº”å·²å¼€å§‹ï¼Œæ— æ³•å‘é€é”™è¯¯ä¿¡æ¯åˆ°å®¢æˆ·ç«¯");
                return new EmptyResult();
            }

            return StatusCode(500, "æ‰“åŒ…æ ‡ç­¾æ—¶å‘ç”Ÿé”™è¯¯");
        }
    }
}
```

### 4. Program.csé…ç½®

```csharp
var builder = WebApplication.CreateBuilder(args);

// âš ï¸ å¯ç”¨åŒæ­¥I/Oï¼ˆZipArchiveéœ€è¦ï¼‰
builder.Services.Configure<KestrelServerOptions>(options =>
{
    options.AllowSynchronousIO = true;
});

// å¦‚æœéƒ¨ç½²åœ¨IISä¸Š
builder.Services.Configure<IISServerOptions>(options =>
{
    options.AllowSynchronousIO = true;
});

// æ³¨å†ŒæœåŠ¡
builder.Services.AddHttpClient();
builder.Services.AddScoped<ILabelPackService, LabelPackService>();

builder.Services.AddControllers();

var app = builder.Build();

app.MapControllers();
app.Run();
```

## ä½¿ç”¨ç¤ºä¾‹

### å‰ç«¯è¯·æ±‚

```json
POST /api/label/pack
Content-Type: application/json

[
  {
    "planNo": "PLAN2025001",
    "boxes": [
      {
        "boxNo": "BOX001",
        "labelUrls": [
          "https://example.com/label1.jpg",
          "https://example.com/label2.png"
        ]
      },
      {
        "boxNo": "BOX002",
        "labelUrls": [
          "https://example.com/label3.jpg"
        ]
      }
    ]
  }
]
```

### ç”Ÿæˆçš„ZIPç»“æ„

```
Labels_20250103120000.zip
â”œâ”€â”€ PLAN2025001/
â”‚   â”œâ”€â”€ BOX001/
â”‚   â”‚   â”œâ”€â”€ æ ‡ç­¾_1.jpg
â”‚   â”‚   â””â”€â”€ æ ‡ç­¾_2.png
â”‚   â””â”€â”€ BOX002/
â”‚       â””â”€â”€ æ ‡ç­¾_1.jpg
```

## æ€§èƒ½å¯¹æ¯”

| åœºæ™¯ | ä¼ ç»Ÿæ–¹æ¡ˆå†…å­˜å ç”¨ | æµå¼æ–¹æ¡ˆå†…å­˜å ç”¨ | ä¼˜åŒ–æ•ˆæœ |
|------|----------------|----------------|----------|
| 10å¼  Ã— 5MB | ~100MB | ~80KB | èŠ‚çœ99.9% |
| 100å¼  Ã— 5MB | ~1GB | ~80KB | èŠ‚çœ99.99% |
| 1000å¼  Ã— 5MB | ~10GB | ~80KB | èŠ‚çœ99.999% |

## å¸¸è§é—®é¢˜

### 1. å‡ºç° "Synchronous operations are disallowed" é”™è¯¯

**åŸå› **ï¼šASP.NET Core é»˜è®¤ç¦ç”¨åŒæ­¥I/Oæ“ä½œ

**è§£å†³**ï¼šåœ¨ `Program.cs` ä¸­æ·»åŠ ï¼š
```csharp
builder.Services.Configure<KestrelServerOptions>(options =>
{
    options.AllowSynchronousIO = true;
});
```

### 2. å‡ºç° "Property accessor 'Length' on object threw exception" é”™è¯¯

**åŸå› **ï¼šABP Frameworkçš„éªŒè¯æœºåˆ¶è¯•å›¾éªŒè¯æµå¯¹è±¡

**è§£å†³**ï¼šåœ¨Controlleræ–¹æ³•ä¸Šæ·»åŠ  `[DisableValidation]` ç‰¹æ€§

### 3. ZIPæ–‡ä»¶æŸå

**åŸå› **ï¼šå“åº”å‹ç¼©ä¸­é—´ä»¶å¯¹ZIPè¿›è¡Œäº†äºŒæ¬¡å‹ç¼©

**è§£å†³**ï¼šé…ç½®å“åº”å‹ç¼©æ’é™¤ZIPæ–‡ä»¶ï¼š
```csharp
builder.Services.AddResponseCompression(options =>
{
    options.MimeTypes = ResponseCompressionDefaults.MimeTypes
        .Where(x => x != "application/zip");
});
```

## è¿›é˜¶ä¼˜åŒ–

### 1. æ·»åŠ è¿›åº¦åé¦ˆ

ä½¿ç”¨SignalRå®æ—¶æ¨é€æ‰“åŒ…è¿›åº¦ï¼š

```csharp
// åœ¨æœåŠ¡ä¸­æ³¨å…¥IHubContext
private readonly IHubContext<ProgressHub> _hubContext;

// ä¸‹è½½æ—¶æ¨é€è¿›åº¦
await _hubContext.Clients.User(userId)
    .SendAsync("ProgressUpdate", new {
        current = i,
        total = totalCount
    });
```

### 2. åå°ä»»åŠ¡å¤„ç†

å¯¹äºè¶…å¤§ä»»åŠ¡ï¼Œä½¿ç”¨åå°é˜Ÿåˆ—ï¼š

```csharp
[HttpPost("pack-async")]
public async Task<IActionResult> PackLabelsAsync([FromBody] List<PlanLabelTask> plans)
{
    var taskId = Guid.NewGuid().ToString();

    // åŠ å…¥åå°é˜Ÿåˆ—
    await _backgroundTaskQueue.QueueBackgroundWorkItemAsync(async token =>
    {
        await ProcessLargePackTask(taskId, plans, token);
    });

    return Ok(new { taskId, message = "ä»»åŠ¡å·²æäº¤" });
}
```

### 3. æ·»åŠ é™æµ

é˜²æ­¢æ¶æ„è¯·æ±‚ï¼š

```csharp
builder.Services.AddRateLimiter(options =>
{
    options.AddFixedWindowLimiter("pack", opt =>
    {
        opt.Window = TimeSpan.FromMinutes(1);
        opt.PermitLimit = 10;
    });
});
```

## æ€»ç»“

é€šè¿‡æµå¼å¤„ç†ï¼Œæˆ‘ä»¬æˆåŠŸå®ç°äº†ï¼š

âœ… **ä½å†…å­˜å ç”¨**ï¼šä»GBçº§åˆ«é™ä½åˆ°KBçº§åˆ«
âœ… **é«˜å¹¶å‘æ”¯æŒ**ï¼šå¤šç”¨æˆ·åŒæ—¶ä¸‹è½½äº’ä¸å½±å“
âœ… **å®æ—¶ä¼ è¾“**ï¼šè¾¹ä¸‹è½½è¾¹ä¼ è¾“ï¼Œç”¨æˆ·ä½“éªŒå¥½
âœ… **å¼‚å¸¸å¤„ç†**ï¼šå•ä¸ªå›¾ç‰‡å¤±è´¥ä¸å½±å“æ•´ä½“æµç¨‹

è¿™å¥—æ–¹æ¡ˆå·²åœ¨ç”Ÿäº§ç¯å¢ƒç¨³å®šè¿è¡Œï¼Œå¤„ç†è¿‡å•æ¬¡1000+å›¾ç‰‡çš„æ‰“åŒ…ä»»åŠ¡ï¼Œå†…å­˜å ç”¨å§‹ç»ˆä¿æŒåœ¨100MBä»¥å†…ã€‚

## å‚è€ƒèµ„æ–™

- [System.IO.Compression æ–‡æ¡£](https://learn.microsoft.com/en-us/dotnet/api/system.io.compression)
- [ASP.NET Core æµå¼ä¼ è¾“](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/streaming)
- [HttpClient æœ€ä½³å®è·µ](https://learn.microsoft.com/en-us/dotnet/fundamentals/networking/http/httpclient-guidelines)

---

**é¡¹ç›®ç¯å¢ƒ**ï¼š.NET 8 + ASP.NET Core + ABP Framework
